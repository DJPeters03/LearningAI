<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Self-Learning Agent (Mobile)</title>
<style>
  :root {
    --bg:#0b1020; --fg:#e8eefc; --muted:#9fb3ff; --glass:rgba(255,255,255,0.06);
    --accent:#7ee787; --warn:#ff7b72; --gold:#ffd166;
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Arial;}
  #app{position:fixed; inset:0; display:flex; flex-direction:column;}
  header{padding:10px 12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; background:var(--glass); backdrop-filter:blur(6px);}
  header .pill{display:inline-flex; align-items:center; gap:8px; padding:8px 10px; border-radius:999px; background:rgba(255,255,255,0.08);}
  header button, header select{
    appearance:none; border:0; border-radius:999px; padding:10px 14px; font-weight:600; color:var(--bg);
    background:var(--accent); cursor:pointer;
  }
  header button.secondary{background:var(--gold); color:#1d1500;}
  header button.danger{background:var(--warn); color:#330;}
  header label{display:flex; flex-direction:column; font-size:12px; gap:6px;}
  header input[type=range]{width:140px;}
  #stats{margin-left:auto; font-variant-numeric:tabular-nums;}
  #canvas{flex:1; width:100%; height:100%;}
  #footer{padding:8px 12px; background:var(--glass); font-size:12px; color:var(--muted);}
  .dot{display:inline-block; width:10px; height:10px; border-radius:50%;}
  .legend{display:flex; gap:10px; align-items:center; flex-wrap:wrap;}
  .k{display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:10px; background:rgba(255,255,255,0.05);}
</style>
</head>
<body>
<div id="app">
  <header>
    <button id="btnToggle">▶ Run</button>
    <button id="btnStep" class="secondary">Step</button>
    <!-- label changed only -->
    <button id="btnReset" class="danger">Next Map</button>
    <div class="pill">
      <label>Speed <input id="speed" type="range" min="0.2" max="5" step="0.1" value="1.0"></label>
      <label>Population <input id="pop" type="range" min="1" max="120" step="1" value="1"></label>
      <label>Mutation % <input id="mut" type="range" min="1" max="50" step="1" value="12"></label>
    </div>
    <div class="pill">
      <label>Sensors <input id="sensors" type="range" min="3" max="13" step="2" value="9"></label>
      <label>Obstacles <input id="obs" type="range" min="4" max="28" step="2" value="12"></label>
    </div>
    <div id="stats" class="pill">
      Gen <b id="gen">0</b> • Best <b id="best">0.00</b> • Reached <b id="wins">0</b>
    </div>
  </header>

  <canvas id="canvas"></canvas>

  <div id="footer">
    <div class="legend">
      <span class="k"><span class="dot" style="background:#7ee787"></span> Best agent</span>
      <span class="k"><span class="dot" style="background:#58a6ff"></span> Others</span>
      <span class="k"><span class="dot" style="background:#ffd166"></span> Goal</span>
      <span class="k"><span class="dot" style="background:#ff7b72"></span> Obstacles</span>
      <span class="k">Tap canvas: move goal • Drag: pan start</span>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Canvas & DPR =====
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  function resize() {
    canvas.width = Math.floor(canvas.clientWidth * DPR);
    canvas.height = Math.floor(canvas.clientHeight * DPR);
  }
  new ResizeObserver(resize).observe(canvas);

  // ===== UI =====
  const btnToggle = document.getElementById('btnToggle');
  const btnStep = document.getElementById('btnStep');
  const btnReset = document.getElementById('btnReset');
  const uiSpeed = document.getElementById('speed');
  const uiPop = document.getElementById('pop');
  const uiMut = document.getElementById('mut');
  const uiSensors = document.getElementById('sensors');
  const uiObs = document.getElementById('obs');
  const genEl = document.getElementById('gen');
  const bestEl = document.getElementById('best');
  const winsEl = document.getElementById('wins');

  // Safety buffers (tweak freely)
  const SAFETY = {
    startRadius: 60,
    goalRadius: 26,
    launchDist: 140,
    launchHalfAngle: Math.PI/4,
    wallPad: 24
  };

  // Geometry helpers
  function rectClosestPoint(px, py, r){
    const cx = Math.max(r.x, Math.min(px, r.x + r.w));
    const cy = Math.max(r.y, Math.min(py, r.y + r.h));
    return {cx, cy};
  }
  function circleRectOverlap(cx, cy, rad, r){
    const q = rectClosestPoint(cx, cy, r);
    const dx = q.cx - cx, dy = q.cy - cy;
    return (dx*dx + dy*dy) <= rad*rad;
  }
  function rectIntersectsLaunchSector(r){
    const {cx, cy} = rectClosestPoint(WORLD.start.x, WORLD.start.y, r);
    const vx = cx - WORLD.start.x, vy = cy - WORLD.start.y;
    const d  = Math.hypot(vx, vy);
    if (d === 0) return true;
    const dir = Math.atan2(WORLD.goal.y - WORLD.start.y, WORLD.goal.x - WORLD.start.x);
    let a = Math.atan2(vy, vx) - dir;
    while (a >  Math.PI) a -= 2*Math.PI;
    while (a < -Math.PI) a += 2*Math.PI;
    return (d < SAFETY.launchDist) && (Math.abs(a) <= SAFETY.launchHalfAngle);
  }
  function rectInsideWorld(r){
    return r.x >= SAFETY.wallPad &&
           r.y >= SAFETY.wallPad &&
           (r.x + r.w) <= (WORLD.w - SAFETY.wallPad) &&
           (r.y + r.h) <= (WORLD.h - SAFETY.wallPad);
  }

  // ===== World settings =====
  let running = false;
  let tickScale = 1.0;
  let generation = 0;
  let wins = 0;

  let WORLD = {
    w: 900, h: 600,
    start: {x: 90, y: 300},
    goal:  {x: 810, y: 300, r: 18},
    obstacles: [],
    nObstacles: +uiObs.value
  };

  // Touch helpers
  let touching = false, lastTouch = null, panStart = {...WORLD.start};
  canvas.addEventListener('pointerdown', e => {
    touching = true;
    lastTouch = {x:e.clientX, y:e.clientY};
    panStart = {...WORLD.start};
  });
  canvas.addEventListener('pointerup', () => { touching = false; });
  canvas.addEventListener('pointermove', e => {
    if (!touching) return;
    const dx = (e.clientX - lastTouch.x) * (WORLD.w / canvas.clientWidth);
    const dy = (e.clientY - lastTouch.y) * (WORLD.h / canvas.clientHeight);
    if (e.shiftKey) {
      WORLD.goal.x = clamp(WORLD.goal.x + dx, 40, WORLD.w-40);
      WORLD.goal.y = clamp(WORLD.goal.y + dy, 40, WORLD.h-40);
    } else {
      WORLD.start.x = clamp(panStart.x + dx, 20, WORLD.w-20);
      WORLD.start.y = clamp(panStart.y + dy, 20, WORLD.h-20);
    }
  });
  canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (WORLD.w / rect.width);
    const y = (e.clientY - rect.top)  * (WORLD.h / rect.height);
    WORLD.goal.x = clamp(x, 40, WORLD.w-40);
    WORLD.goal.y = clamp(y, 40, WORLD.h-40);
  });

  // ===== Random & math =====
  const rand = (a=1,b=0)=>Math.random()*(a-b)+b;
  const randi = (a,b)=>Math.floor(rand(a,b));
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const wrapPI=a=>{while(a>Math.PI)a-=2*Math.PI;while(a<-Math.PI)a+=2*Math.PI;return a;}

  // ===== Obstacles =====
  function regenObstacles(n = WORLD.nObstacles) {
    const obs = [];
    const pad = 40;
    const maxAttempts = 2000;
    let attempts = 0;

    while (obs.length < n && attempts < maxAttempts) {
      attempts++;

      const w = rand(40, 120);
      const h = rand(40, 120);

      let x, y;
      const mustBlock = (obs.length < Math.min(4, n));
      if (mustBlock) {
        const t = rand(0.28, 0.78);
        x = lerp(WORLD.start.x, WORLD.goal.x, t) + rand(-90, 90);
        y = lerp(WORLD.start.y, WORLD.goal.y, t) + rand(-90, 90);
      } else {
        x = rand(pad, WORLD.w - pad - w);
        y = rand(pad, WORLD.h - pad - h);
      }

      const r = {x, y, w, h};

      if (!rectInsideWorld(r)) continue;
      const startBlock = circleRectOverlap(WORLD.start.x, WORLD.start.y, SAFETY.startRadius + 8, r);
      if (startBlock) continue;
      const goalBlock  = circleRectOverlap(WORLD.goal.x,  WORLD.goal.y,  SAFETY.goalRadius, r);
      if (goalBlock) continue;
      if (rectIntersectsLaunchSector(r)) continue;

      let overlaps = false;
      for (const o of obs) {
        if (x < o.x + o.w && x + w > o.x && y < o.y + o.h && y + h > o.y) { overlaps = true; break; }
      }
      if (overlaps) continue;

      obs.push(r);
    }

    WORLD.obstacles = obs;
  }

  // ===== Tiny Neural Net =====
  function createBrain(nIn, nH=12){
    function gl(n,m){
      const arr = new Float32Array(n*m);
      for (let i=0;i<arr.length;i++) arr[i] = (Math.random()*2-1)*Math.sqrt(2/(n));
      return arr;
    }
    return { nIn, nH, W1: gl(nH, nIn), b1: gl(nH,1), W2: gl(2, nH), b2: gl(2,1) };
  }
  function cloneBrain(b){
    return {
      nIn: b.nIn, nH: b.nH,
      W1: new Float32Array(b.W1), b1: new Float32Array(b.b1),
      W2: new Float32Array(b.W2), b2: new Float32Array(b.b2)
    };
  }
  function mixArrays(a, b){
    const out = new Float32Array(a.length);
    for (let i=0;i<a.length;i++){
      const alpha = Math.random();
      out[i] = (1-alpha)*a[i] + alpha*b[i];
    }
    return out;
  }
  function mixBrains(p, q){
    return {
      nIn: p.nIn, nH: p.nH,
      W1: mixArrays(p.W1, q.W1),
      b1: mixArrays(p.b1, q.b1),
      W2: mixArrays(p.W2, q.W2),
      b2: mixArrays(p.b2, q.b2),
    };
  }
  function addMinimumNoise(b, floorRate=0.03){
    const s = floorRate;
    const jitter = (arr) => {
      for (let i=0;i<arr.length;i++){
        arr[i] += (Math.random()*2-1) * 0.1 * s;
      }
    };
    jitter(b.W1); jitter(b.b1); jitter(b.W2); jitter(b.b2);
  }
  function mutateBrain(b, ratePct=12){
    const s = ratePct/100;
    const jitter = (arr) => {
      for (let i=0;i<arr.length;i++){
        if (Math.random()<0.2) arr[i] += (Math.random()*2-1)*0.5*s;
        else arr[i] += (Math.random()*2-1)*0.1*s;
      }
    };
    jitter(b.W1); jitter(b.b1); jitter(b.W2); jitter(b.b2);
  }
  function forward(b, x){
    const h = new Float32Array(b.nH);
    for (let i=0;i<b.nH;i++){
      let sum = b.b1[i];
      for (let j=0;j<b.nIn;j++) sum += b.W1[i*b.nIn + j] * x[j];
      h[i] = Math.tanh(sum);
    }
    const y = new Float32Array(2);
    for (let k=0;k<2;k++){
      let s = b.b2[k];
      for (let i=0;i<b.nH;i++) s += b.W2[k*b.nH + i] * h[i];
      y[k] = k===0 ? Math.tanh(s) : 1/(1+Math.exp(-s));
    }
    return y; // [steer, throttle]
  }

  // ===== Agent =====
  const TWO_TURNS = Math.PI * 4;
  const STALE_LIMIT = 120;
  const STALE_EPS   = 0.5;

  function makeAgent(params){
    const agent = {
      x: WORLD.start.x, y: WORLD.start.y,
      ang: 0, v: 0, radius: 8,
      alive: true, steps:0, reached:false,
      brain: params.brain,
      sensors: params.sensors,
      maxSpeed: 3.0, steerLimit: 0.16, acc: 0.16,
      minDist: Infinity, lastDist: Infinity,
      cumTurn: 0, lastAng: 0, spunOut: false,
      staleTicks: 0, fitness: 0, history: []
    };
    agent.ang = Math.atan2(WORLD.goal.y - agent.y, WORLD.goal.x - agent.x);
    agent.lastAng = agent.ang;
    agent.lastDist = dist(agent.x,agent.y, WORLD.goal.x,WORLD.goal.y);
    agent.minDist  = agent.lastDist;
    agent.fitness  = 1/(1+agent.minDist);
    return agent;
  }

  function resetAgent(a){
    a.x = WORLD.start.x; a.y = WORLD.start.y;
    a.ang = Math.atan2(WORLD.goal.y - a.y, WORLD.goal.x - a.x);
    a.lastAng = a.ang;
    a.v = 0; a.alive = true; a.reached=false; a.spunOut=false;
    a.steps=0; a.history.length=0;
    a.lastDist = dist(a.x,a.y, WORLD.goal.x,WORLD.goal.y);
    a.minDist  = a.lastDist;
    a.fitness  = 1/(1+a.minDist);
    a.cumTurn = 0;
    a.staleTicks = 0;
  }

  function sense(agent){
    const n = agent.sensors;
    const maxR = 120;
    const inputs = [];
    const spread = Math.PI * 1.2;
    for (let i=0;i<n;i++){
      const a = agent.ang + (i/(n-1)-0.5)*spread;
      const res = castRay(agent.x, agent.y, a, maxR);
      inputs.push(res/maxR);
    }
    const gAng = Math.atan2(WORLD.goal.y-agent.y, WORLD.goal.x-agent.x);
    const dAng = wrapPI(gAng - agent.ang) / Math.PI;
    const dGoal = dist(agent.x,agent.y, WORLD.goal.x,WORLD.goal.y);
    inputs.push(dAng);
    inputs.push(Math.min(1, dGoal / Math.hypot(WORLD.w, WORLD.h)));
    inputs.push(agent.v / agent.maxSpeed);
    return new Float32Array(inputs);
  }

  function castRay(x,y,ang,maxR){
    const step = 4;
    let d = 0;
    while (d < maxR){
      const px = x + Math.cos(ang)*d;
      const py = y + Math.sin(ang)*d;
      if (px<0 || py<0 || px>WORLD.w || py>WORLD.h) return d;
      for (const o of WORLD.obstacles){
        if (px>=o.x && px<=o.x+o.w && py>=o.y && py<=o.y+o.h) return d;
      }
      d += step;
    }
    return maxR;
  }

  function stepAgent(a){
    if (!a.alive || a.reached) return;
    const inputs = sense(a);
    const out = forward(a.brain, inputs);
    const steer = clamp(out[0], -1, 1) * a.steerLimit;
    const throttle = out[1];

    const newAng = a.ang + steer;
    const dYaw = wrapPI(newAng - a.lastAng);
    a.cumTurn += Math.abs(dYaw);
    a.ang = newAng;
    a.lastAng = newAng;
    if (a.cumTurn >= TWO_TURNS) { a.spunOut = true; a.alive = false; }

    a.v = clamp(a.v + (throttle-0.25)*a.acc, 0, a.maxSpeed);
    a.x += Math.cos(a.ang)*a.v;
    a.y += Math.sin(a.ang)*a.v;
    a.history.push(a.x, a.y);
    if (a.history.length > 2*120) a.history.splice(0,2);

    if (a.x<10 || a.y<10 || a.x>WORLD.w-10 || a.y>WORLD.h-10) a.alive=false;

    if (a.alive){
      for (const o of WORLD.obstacles){
        if (a.x+a.radius>o.x && a.x-a.radius<o.x+o.w && a.y+a.radius>o.y && a.y-a.radius<o.y+o.h){
          a.alive = false; break;
        }
      }
    }

    if (a.alive && dist(a.x,a.y, WORLD.goal.x,WORLD.goal.y) < (WORLD.goal.r + a.radius)){
      a.reached = true; a.alive = false; wins++;
      roundWon = true; // triggers evolution on SAME MAP
    }

    const dNow = dist(a.x,a.y, WORLD.goal.x,WORLD.goal.y);
    if (dNow < a.minDist - STALE_EPS) {
      a.minDist = dNow;
      a.staleTicks = 0;
    } else {
      a.staleTicks++;
      if (a.staleTicks > STALE_LIMIT) a.alive = false;
    }
    a.fitness = a.reached ? 1000 : (a.spunOut ? 0 : 1/(1+a.minDist));
    a.steps++;
  }

  function scoreAgent(a){
    if (a.reached) return a.fitness = 1000;
    if (a.spunOut) return a.fitness = 0;
    return a.fitness = 1/(1+a.minDist);
  }

  // ===== Population / GA =====
  let POP = [];
  let POP_SIZE = +uiPop.value;
  let SENSORS = +uiSensors.value;
  let MUT = +uiMut.value;

  // Bootstrap first two gens random
  let bootstrapArchive = [];
  const BOOTSTRAP_TARGET = 2;

  function newPopulationRandom(size = POP_SIZE){
    POP = [];
    for (let i=0;i<size;i++){
      const brain = createBrain(SENSORS + 3);
      POP.push(makeAgent({brain, sensors:SENSORS}));
    }
  }
  function resetPopulationPositions(){ for (const a of POP) resetAgent(a); }

  function evolve(wasWin=false){
    const scored = POP.map(a => ({a, fit: scoreAgent(a)}));
    scored.sort((x,y)=>y.fit-x.fit);
    const bestFit = scored[0].fit;

    if (bootstrapArchive.length < BOOTSTRAP_TARGET){
      bootstrapArchive.push({brain: cloneBrain(scored[0].a.brain), fit: bestFit});
    } else {
      const idxWeak = (bootstrapArchive[0].fit < bootstrapArchive[1].fit) ? 0 : 1;
      if (bestFit > bootstrapArchive[idxWeak].fit){
        bootstrapArchive[idxWeak] = {brain: cloneBrain(scored[0].a.brain), fit: bestFit};
      }
    }

    let next = [];
    if (bootstrapArchive.length < BOOTSTRAP_TARGET){
      for (let i=0;i<POP_SIZE;i++){
        const brain = createBrain(SENSORS + 3);
        next.push(makeAgent({brain, sensors:SENSORS}));
      }
    } else {
      const A = bootstrapArchive[0].fit >= bootstrapArchive[1].fit ? bootstrapArchive[0] : bootstrapArchive[1];
      const B = bootstrapArchive[0].fit <  bootstrapArchive[1].fit ? bootstrapArchive[0] : bootstrapArchive[1];
      const C = scored[0].a.brain;

      const parentPool = [A.brain, B.brain, C];
      for (let i=0;i<POP_SIZE; i++){
        const p = parentPool[randi(0, parentPool.length)];
        let q = parentPool[randi(0, parentPool.length)];
        if (q === p && parentPool.length > 1){
          q = parentPool[(parentPool.indexOf(p)+1)%parentPool.length];
        }
        let child = mixBrains(p, q);
        addMinimumNoise(child, 0.03);
        mutateBrain(child, MUT);
        next.push(makeAgent({brain: child, sensors:SENSORS}));
      }
    }

    POP = next;

    generation++;
    genEl.textContent = generation;
    bestEl.textContent = bestFit.toFixed(2);
    winsEl.textContent = wins;

    // IMPORTANT CHANGE:
    // On win, DO NOT regenerate obstacles anymore — evolve on the SAME MAP
    // (Map only changes via Next Map button or obstacle slider.)
    // if (wasWin) { regenObstacles(WORLD.nObstacles); bootstrapArchive = []; }

    resetPopulationPositions();

    genBestMinDist = Infinity;
    genStaleTicks = 0;
  }

  // ===== Main loop =====
  let acc = 0, lastT = 0;
  let roundWon = false;

  function loop(t){
    const dt = Math.min(32, t - lastT); lastT = t;
    acc += dt * tickScale;
    const stepMs = 16;
    while (acc >= stepMs){
      update();
      acc -= stepMs;
    }
    render();
    if (running) requestAnimationFrame(loop);
  }

  let simTicks = 0;
  const ROUND_TICKS = 600;
  let genBestMinDist = Infinity;
  let genStaleTicks = 0;
  const GEN_STALE_LIMIT = 240;

  function update(){
    simTicks++;

    let allDone = true;
    let roundImproved = false;
    for (const a of POP){
      if (a.alive) {
        stepAgent(a);
        allDone = false;
      }
      if (a.minDist < genBestMinDist - STALE_EPS) {
        genBestMinDist = a.minDist;
        roundImproved = true;
      }
    }
    genStaleTicks = roundImproved ? 0 : genStaleTicks+1;

    if (roundWon || allDone || simTicks>=ROUND_TICKS || genStaleTicks >= GEN_STALE_LIMIT){
      simTicks = 0;
      evolve(roundWon);   // will NOT change the map anymore
      roundWon = false;
    }
  }

  function render(){
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);
    const scale = Math.min(W / WORLD.w, H / WORLD.h);
    const ox = (W - WORLD.w*scale)/2;
    const oy = (H - WORLD.h*scale)/2;

    const tx = x => Math.round(ox + x*scale);
    const ty = y => Math.round(oy + y*scale);
    const ts = s => Math.max(1, Math.round(s*scale));

    ctx.fillStyle = '#0c1730';
    roundRect(ctx, ox-8, oy-8, WORLD.w*scale+16, WORLD.h*scale+16, 14);
    ctx.fill();

    ctx.fillStyle = '#ffd166';
    ctx.beginPath();
    ctx.arc(tx(WORLD.goal.x), ty(WORLD.goal.y), ts(WORLD.goal.r), 0, Math.PI*2);
    ctx.fill();

    ctx.fillStyle = '#ff7b72';
    for (const o of WORLD.obstacles){
      roundRect(ctx, tx(o.x), ty(o.y), ts(o.w), ts(o.h), 8);
      ctx.fill();
    }

    let best = POP[0];
    for (const a of POP){ if (a.fitness > best.fitness) best = a; }

    for (const a of POP){
      const isBest = a === best;

      if (a.history.length>4){
        ctx.globalAlpha = isBest ? 0.9 : 0.4;
        ctx.strokeStyle = isBest ? '#7ee787' : '#58a6ff';
        ctx.lineWidth = isBest ? 3 : 1.5;
        ctx.beginPath();
        for (let i=0;i<a.history.length;i+=2){
          const px = tx(a.history[i]), py = ty(a.history[i+1]);
          if (i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
      }

      ctx.fillStyle = isBest ? '#7ee787' : (a.spunOut ? '#aa5577' : '#58a6ff');
      ctx.beginPath();
      ctx.arc(tx(a.x), ty(a.y), ts(a.radius), 0, Math.PI*2);
      ctx.fill();

      ctx.strokeStyle = '#000';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(tx(a.x), ty(a.y));
      ctx.lineTo(tx(a.x + Math.cos(a.ang)*a.radius*1.4),
                 ty(a.y + Math.sin(a.ang)*a.radius*1.4));
      ctx.stroke();

      if (isBest){
        const n = a.sensors, maxR = 120, spread = Math.PI*1.2;
        ctx.strokeStyle = 'rgba(255,255,255,0.25)';
        ctx.lineWidth = 1;
        for (let i=0;i<n;i++){
          const ang = a.ang + (i/(n-1)-0.5)*spread;
          const d = castRay(a.x, a.y, ang, maxR);
          ctx.beginPath();
          ctx.moveTo(tx(a.x), ty(a.y));
          ctx.lineTo(tx(a.x + Math.cos(ang)*d), ty(a.y + Math.sin(ang)*d));
          ctx.stroke();
        }
      }
    }

    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = `${Math.round(14*DPR)}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    ctx.fillText(`Gen ${generation}   Wins ${wins}`, 14*DPR, 22*DPR);
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x, y+h, r);
    ctx.arcTo(x,y+h, x, y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  // ===== Map & Controls =====
function nextMap(){
  // Reset evolution state to Gen 0
  generation = 0;
  genEl.textContent = '0';
  bestEl.textContent = '0.00';
  bootstrapArchive = [];          // re-bootstrap on the new course

  // (Optional) also reset win counter:
  // wins = 0; winsEl.textContent = '0';

  // New course + brand-new Gen 0 population
  regenObstacles(WORLD.nObstacles);
  newPopulationRandom(POP_SIZE);
  resetPopulationPositions();

  // Reset round/gen timers
  simTicks = 0;
  genBestMinDist = Infinity;
  genStaleTicks = 0;
  roundWon = false;

  // Redraw immediately
  render();
}


  btnToggle.addEventListener('click', () => {
    running = !running;
    btnToggle.textContent = running ? '⏸ Pause' : '▶ Run';
    if (running) { lastT = performance.now(); requestAnimationFrame(loop); }
  });

  btnStep.addEventListener('click', () => {
    if (running) return;
    for (let i=0;i<8;i++) update();
    render();
  });

  // BUTTON still id=btnReset, label changed to "Next Map"
  btnReset.addEventListener('click', nextMap);

  uiSpeed.addEventListener('input', () => tickScale = +uiSpeed.value);

  // Do NOT reset course when changing population or sensors
  uiPop.addEventListener('change', () => {
    POP_SIZE = +uiPop.value;
    rebuildPopulationKeepCourse();
  });
  uiMut.addEventListener('input', () => { MUT = +uiMut.value; });
  uiSensors.addEventListener('change', () => {
    SENSORS = +uiSensors.value;
    rebuildPopulationKeepCourse(true);
  });

  // Adjusting obstacles -> regenerate map AND reset agents (already done)
  uiObs.addEventListener('change', () => {
    WORLD.nObstacles = +uiObs.value;
    nextMap(); // replaces the previous inline calls
  });

  function rebuildPopulationKeepCourse(requiresNewBrains=false){
    let next = [];
    if (requiresNewBrains){
      for (let i=0;i<POP_SIZE;i++){
        const brain = createBrain(SENSORS + 3);
        next.push(makeAgent({brain, sensors:SENSORS}));
      }
      // keep archive if you want, or clear if perception changed drastically:
      // bootstrapArchive = [];
    } else {
      for (let i=0;i<Math.min(POP.length, POP_SIZE); i++){
        const a = POP[i];
        a.sensors = SENSORS;
        let b = cloneBrain(a.brain);
        addMinimumNoise(b, 0.03);
        next.push(makeAgent({brain: b, sensors:SENSORS}));
      }
      while (next.length < POP_SIZE){
        const brain = createBrain(SENSORS + 3);
        next.push(makeAgent({brain, sensors:SENSORS}));
      }
    }
    POP = next;
    resetPopulationPositions();
  }

  // Hard boot to initialize the very first map & population
  function hardBoot(){
    WORLD.w = Math.round(Math.max(680, window.innerWidth  * 0.9));
    WORLD.h = Math.round(Math.max(420, (window.innerHeight-120) * 0.9));
    WORLD.start = {x: 0.1*WORLD.w, y: 0.5*WORLD.h};
    WORLD.goal  = {x: 0.9*WORLD.w, y: 0.5*WORLD.h, r: 18};
    regenObstacles(WORLD.nObstacles);
    newPopulationRandom(POP_SIZE);
    resetPopulationPositions();
    render();
  }

  // ===== Boot =====
  tickScale = +uiSpeed.value;
  hardBoot();
  setTimeout(()=>{ if(!running){ btnToggle.click(); } }, 300);
})();
</script>
</body>
</html>

