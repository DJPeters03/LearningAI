<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Self-Learning Agent — Tunable (Mobile)</title>
<style>
  :root{
    --bg:#0b1020; --fg:#e8eefc; --muted:#9fb3ff; --glass:rgba(255,255,255,0.06);
    --accent:#7ee787; --warn:#ff7b72; --gold:#ffd166; --panel:rgba(255,255,255,0.08);
  }
  *{box-sizing:border-box; -webkit-tap-highlight-color:transparent}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  #app{position:fixed; inset:0; display:flex; flex-direction:column}
  header{padding:10px 12px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; background:var(--glass); backdrop-filter:blur(6px)}
  header .pill{display:inline-flex; align-items:center; gap:10px; padding:8px 10px; border-radius:999px; background:var(--panel)}
  header button, header select{
    appearance:none; border:0; border-radius:999px; padding:10px 14px; font-weight:600; color:#08111f; background:var(--accent); cursor:pointer
  }
  header button.secondary{background:var(--gold); color:#1d1500}
  header button.danger{background:var(--warn); color:#330}
  header label{display:flex; flex-direction:column; font-size:12px; gap:6px}
  header input[type=range]{width:140px}
  #stats{margin-left:auto; font-variant-numeric:tabular-nums}
  #canvas{flex:1; width:100%; height:100%}
  #footer{padding:8px 12px; background:var(--glass); font-size:12px; color:var(--muted)}
  .dot{display:inline-block; width:10px; height:10px; border-radius:50%}
  .legend{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
  .k{display:inline-flex; gap:6px; align-items:center; padding:6px 10px; border-radius:10px; background:rgba(255,255,255,0.05)}
  /* collapsible control shelf for small screens */
  #shelf{display:flex; flex-wrap:wrap; gap:8px; padding:8px 12px; background:var(--glass)}
  details.slab{border-radius:14px; background:var(--panel); padding:8px 10px}
  details summary{cursor:pointer; font-weight:700}
  .grid{display:grid; grid-template-columns:repeat(2,minmax(140px,1fr)); gap:12px 18px; padding:8px 0}
  .grid label{gap:4px}
</style>
</head>
<body>
<div id="app">
  <header>
    <button id="btnToggle">▶ Run</button>
    <button id="btnStep" class="secondary">Step</button>
    <button id="btnReset" class="danger">Next Map</button>
    <div class="pill">
      <label>Speed <input id="speed" type="range" min="0.2" max="5" step="0.1" value="1.0"></label>
      <label>Population <input id="pop" type="range" min="1" max="200" step="1" value="24"></label>
      <label>Overall Performance Emphasis <input id="perf" type="range" min="0" max="100" step="1" value="40"></label>
    </div>
    <div id="stats" class="pill">
      Gen <b id="gen">0</b> • Best <b id="best">0.00</b> • Reached <b id="wins">0</b>
    </div>
  </header>

  <!-- Collapsible shelves for more knobs -->
  <div id="shelf">
    <details class="slab" open>
      <summary>Learning</summary>
      <div class="grid">
        <label>Mutation % <input id="mut" type="range" min="0" max="80" step="1" value="12"></label>
        <label>Noise Floor % <input id="noise" type="range" min="0" max="30" step="1" value="3"></label>
        <label>Elitism (keep top) <input id="elite" type="range" min="0" max="20" step="1" value="2"></label>
        <label>Crossover Blend % <input id="blend" type="range" min="0" max="100" step="1" value="50"></label>
        <label>Exploration ε <input id="eps" type="range" min="0" max="0.5" step="0.01" value="0.05"></label>
        <label>Round ticks <input id="round" type="range" min="200" max="1500" step="20" value="600"></label>
        <label>Gen stale limit <input id="gstal" type="range" min="60" max="1000" step="10" value="240"></label>
        <label>Agent stale limit <input id="astal" type="range" min="30" max="600" step="10" value="120"></label>
      </div>
    </details>

    <details class="slab">
      <summary>Sensing & Control</summary>
      <div class="grid">
        <label>Sensors <input id="sensors" type="range" min="3" max="17" step="2" value="9"></label>
        <label>FOV (°) <input id="fov" type="range" min="30" max="210" step="5" value="216"></label>
        <label>Sensor range <input id="srange" type="range" min="40" max="220" step="5" value="120"></label>
        <label>Max speed <input id="vmax" type="range" min="0.5" max="6" step="0.1" value="3"></label>
        <label>Steer limit (rad) <input id="steer" type="range" min="0.02" max="0.8" step="0.02" value="0.16"></label>
        <label>Acceleration <input id="acc" type="range" min="0.02" max="0.6" step="0.02" value="0.16"></label>
      </div>
    </details>

    <details class="slab">
      <summary>World</summary>
      <div class="grid">
        <label>Obstacles <input id="obs" type="range" min="0" max="40" step="1" value="12"></label>
        <label>Goal radius <input id="goalr" type="range" min="8" max="40" step="1" value="18"></label>
        <label>Wall padding <input id="pad" type="range" min="8" max="80" step="2" value="24"></label>
        <label>Launch distance <input id="ldist" type="range" min="40" max="260" step="5" value="140"></label>
        <label>Launch half-angle (°) <input id="lhalf" type="range" min="10" max="90" step="1" value="45"></label>
        <label><span>Auto new map on win</span><input id="autoWin" type="checkbox"></label>
      </div>
    </details>

    <details class="slab">
      <summary>Rewards</summary>
      <div class="grid">
        <label>Goal reward <input id="rGoal" type="range" min="100" max="5000" step="50" value="1000"></label>
        <label>Progress weight <input id="rProg" type="range" min="0" max="5" step="0.1" value="1.0"></label>
        <label>Velocity bonus <input id="rVel" type="range" min="0" max="1" step="0.05" value="0.2"></label>
        <label>Spin penalty <input id="pSpin" type="range" min="0" max="2" step="0.05" value="1.0"></label>
        <label>Crash penalty <input id="pCrash" type="range" min="0" max="2" step="0.05" value="0.0"></label>
      </div>
    </details>
  </div>

  <canvas id="canvas"></canvas>

  <div id="footer">
    <div class="legend">
      <span class="k"><span class="dot" style="background:#7ee787"></span> Best</span>
      <span class="k"><span class="dot" style="background:#58a6ff"></span> Others</span>
      <span class="k"><span class="dot" style="background:#ffd166"></span> Goal</span>
      <span class="k"><span class="dot" style="background:#ff7b72"></span> Obstacles</span>
      <span class="k">Tap: move goal • Drag: pan start (hold Shift to drag goal)</span>
    </div>
  </div>
</div>

<script>
(() => {
  // ===== Canvas & DPR =====
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  function resize(){ canvas.width = Math.floor(canvas.clientWidth * DPR); canvas.height = Math.floor(canvas.clientHeight * DPR); }
  new ResizeObserver(resize).observe(canvas);

  // ===== UI =====
  const $ = id => document.getElementById(id);
  const btnToggle = $('btnToggle'), btnStep=$('btnStep'), btnReset=$('btnReset');
  const ui = {
    speed:$('speed'), pop:$('pop'), perf:$('perf'),
    mut:$('mut'), noise:$('noise'), elite:$('elite'), blend:$('blend'), eps:$('eps'),
    round:$('round'), gstal:$('gstal'), astal:$('astal'),
    sensors:$('sensors'), fov:$('fov'), srange:$('srange'),
    vmax:$('vmax'), steer:$('steer'), acc:$('acc'),
    obs:$('obs'), goalr:$('goalr'), pad:$('pad'), ldist:$('ldist'), lhalf:$('lhalf'),
    autoWin:$('autoWin'),
    rGoal:$('rGoal'), rProg:$('rProg'), rVel:$('rVel'), pSpin:$('pSpin'), pCrash:$('pCrash'),
    gen:$('gen'), best:$('best'), wins:$('wins')
  };

  // ===== Helpers =====
  const rand=(a=1,b=0)=>Math.random()*(a-b)+b;
  const randi=(a,b)=>Math.floor(rand(a,b));
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx,ay-by);
  const wrapPI=a=>{while(a>Math.PI)a-=2*Math.PI;while(a<-Math.PI)a+=2*Math.PI;return a;}

  // ===== World / Safety =====
  let running=false, tickScale=+ui.speed.value;
  let generation=0, wins=0;
  const SAFETY = { startRadius:60, goalRadius:+ui.goalr.value, wallPad:+ui.pad.value, launchDist:+ui.ldist.value, launchHalfAngle: (+ui.lhalf.value) * Math.PI/180 };

  let WORLD = { w:900, h:600, start:{x:90,y:300}, goal:{x:810,y:300,r:+ui.goalr.value}, obstacles:[], nObstacles:+ui.obs.value };

  // Touch / pan
  let touching=false, lastTouch=null, panStart={...WORLD.start};
  canvas.addEventListener('pointerdown', e=>{ touching=true; lastTouch={x:e.clientX,y:e.clientY}; panStart={...WORLD.start}; });
  canvas.addEventListener('pointerup', ()=>{ touching=false; });
  canvas.addEventListener('pointermove', e=>{
    if(!touching) return;
    const dx=(e.clientX-lastTouch.x)*(WORLD.w/canvas.clientWidth);
    const dy=(e.clientY-lastTouch.y)*(WORLD.h/canvas.clientHeight);
    if(e.shiftKey){ WORLD.goal.x = clamp(WORLD.goal.x+dx, 40, WORLD.w-40); WORLD.goal.y = clamp(WORLD.goal.y+dy, 40, WORLD.h-40); }
    else { WORLD.start.x = clamp(panStart.x+dx, 20, WORLD.w-20); WORLD.start.y = clamp(panStart.y+dy, 20, WORLD.h-20); }
  });
  canvas.addEventListener('click', e=>{
    const rect=canvas.getBoundingClientRect();
    const x=(e.clientX-rect.left)*(WORLD.w/rect.width);
    const y=(e.clientY-rect.top)*(WORLD.h/rect.height);
    WORLD.goal.x=clamp(x, 40, WORLD.w-40); WORLD.goal.y=clamp(y, 40, WORLD.h-40);
  });

  // Geometry helpers
  function rectClosestPoint(px,py,r){ const cx=Math.max(r.x,Math.min(px,r.x+r.w)); const cy=Math.max(r.y,Math.min(py,r.y+r.h)); return {cx,cy}; }
  function circleRectOverlap(cx,cy,rad,r){ const q=rectClosestPoint(cx,cy,r); const dx=q.cx-cx, dy=q.cy-cy; return (dx*dx+dy*dy)<=rad*rad; }
  function rectInsideWorld(r){ return r.x>=SAFETY.wallPad && r.y>=SAFETY.wallPad && (r.x+r.w)<= (WORLD.w-SAFETY.wallPad) && (r.y+r.h)<= (WORLD.h-SAFETY.wallPad); }
  function rectIntersectsLaunchSector(r){
    const {cx,cy}=rectClosestPoint(WORLD.start.x,WORLD.start.y,r);
    const vx=cx-WORLD.start.x, vy=cy-WORLD.start.y; const d=Math.hypot(vx,vy); if(d===0) return true;
    const dir=Math.atan2(WORLD.goal.y-WORLD.start.y, WORLD.goal.x-WORLD.start.x);
    let a=Math.atan2(vy,vx)-dir; while(a> Math.PI)a-=2*Math.PI; while(a<-Math.PI)a+=2*Math.PI;
    return (d<SAFETY.launchDist)&&(Math.abs(a)<=SAFETY.launchHalfAngle);
  }

  // Obstacles
  function regenObstacles(n=WORLD.nObstacles){
    const obs=[]; const pad=40; const maxAttempts=2500; let attempts=0;
    while(obs.length<n && attempts<maxAttempts){
      attempts++;
      const w = rand(40, 120), h = rand(40,120);
      let x,y; const mustBlock = (obs.length < Math.min(4,n));
      if(mustBlock){ const t=rand(0.28,0.78); x=lerp(WORLD.start.x,WORLD.goal.x,t)+rand(-90,90); y=lerp(WORLD.start.y,WORLD.goal.y,t)+rand(-90,90); }
      else { x=rand(pad, WORLD.w-pad-w); y=rand(pad, WORLD.h-pad-h); }
      const r={x,y,w,h};
      if(!rectInsideWorld(r)) continue;
      if(circleRectOverlap(WORLD.start.x,WORLD.start.y, SAFETY.startRadius+8, r)) continue;
      if(circleRectOverlap(WORLD.goal.x,WORLD.goal.y, SAFETY.goalRadius, r)) continue;
      if(rectIntersectsLaunchSector(r)) continue;
      let overlap=false; for(const o of obs){ if(x<o.x+o.w && x+w>o.x && y<o.y+o.h && y+h>o.y){ overlap=true; break; } }
      if(overlap) continue;
      obs.push(r);
    }
    WORLD.obstacles=obs;
  }

  // ===== Tiny NN (same shape, tunable blend & noise) =====
  function createBrain(nIn, nH=12){
    function gl(n,m){ const arr=new Float32Array(n*m); for(let i=0;i<arr.length;i++) arr[i]=(Math.random()*2-1)*Math.sqrt(2/(n)); return arr; }
    return { nIn, nH, W1:gl(nH,nIn), b1:gl(nH,1), W2:gl(2,nH), b2:gl(2,1) };
  }
  function cloneBrain(b){ return { nIn:b.nIn,nH:b.nH, W1:new Float32Array(b.W1), b1:new Float32Array(b.b1), W2:new Float32Array(b.W2), b2:new Float32Array(b.b2) }; }
  function mixArrays(a,b,blend01){ const out=new Float32Array(a.length); for(let i=0;i<a.length;i++){ const t = blend01===undefined?Math.random():blend01; out[i]=(1-t)*a[i]+t*b[i]; } return out; }
  function mixBrains(p,q,blend01){ return { nIn:p.nIn, nH:p.nH, W1:mixArrays(p.W1,q.W1,blend01), b1:mixArrays(p.b1,q.b1,blend01), W2:mixArrays(p.W2,q.W2,blend01), b2:mixArrays(p.b2,q.b2,blend01) }; }
  function addNoise(b, floorPct){ const s=floorPct/100; const jit=arr=>{ for(let i=0;i<arr.length;i++) arr[i]+=(Math.random()*2-1)*0.1*s; }; jit(b.W1);jit(b.b1);jit(b.W2);jit(b.b2); }
  function mutate(b, ratePct){ const s=ratePct/100; const jit=arr=>{ for(let i=0;i<arr.length;i++){ if(Math.random()<0.2) arr[i]+=(Math.random()*2-1)*0.5*s; else arr[i]+=(Math.random()*2-1)*0.1*s; } }; jit(b.W1);jit(b.b1);jit(b.W2);jit(b.b2); }
  function forward(b, x){
    const h=new Float32Array(b.nH);
    for(let i=0;i<b.nH;i++){ let s=b.b1[i]; for(let j=0;j<b.nIn;j++) s+=b.W1[i*b.nIn+j]*x[j]; h[i]=Math.tanh(s); }
    const y=new Float32Array(2);
    for(let k=0;k<2;k++){ let s=b.b2[k]; for(let i=0;i<b.nH;i++) s+=b.W2[k*b.nH+i]*h[i]; y[k] = k===0 ? Math.tanh(s) : 1/(1+Math.exp(-s)); }
    return y; // [steer, throttle]
  }

  // ===== Agent =====
  const TWO_TURNS = Math.PI*4;
  function makeAgent(params){
    const a={
      x:WORLD.start.x,y:WORLD.start.y, ang:0,v:0,radius:8, alive:true, reached:false, spun:false,
      steps:0, brain:params.brain, sensors:params.sensors, maxSpeed:params.maxSpeed, steerLimit:params.steer, acc:params.acc,
      minDist:Infinity,lastDist:Infinity,lastAng:0,cumTurn:0,stale:0, fitness:0, history:[]
    };
    a.ang=Math.atan2(WORLD.goal.y-a.y, WORLD.goal.x-a.x);
    a.lastAng=a.ang; a.lastDist=dist(a.x,a.y, WORLD.goal.x,WORLD.goal.y); a.minDist=a.lastDist; a.fitness=1/(1+a.minDist);
    return a;
  }
  function resetAgent(a){
    a.x=WORLD.start.x; a.y=WORLD.start.y;
    a.ang=Math.atan2(WORLD.goal.y-a.y, WORLD.goal.x-a.x); a.lastAng=a.ang;
    a.v=0; a.alive=true; a.reached=false; a.spun=false; a.steps=0; a.history.length=0;
    a.lastDist=dist(a.x,a.y, WORLD.goal.x,WORLD.goal.y); a.minDist=a.lastDist; a.fitness=1/(1+a.minDist);
    a.cumTurn=0; a.stale=0;
  }

  // sensing
  function sense(a){
    const n = a.sensors;
    const maxR = +ui.srange.value;
    const inputs=[];
    const spread = (+ui.fov.value) * Math.PI/180;
    for(let i=0;i<n;i++){
      const ang=a.ang + (i/(n-1)-0.5)*spread;
      const d=castRay(a.x,a.y,ang,maxR);
      inputs.push(d/maxR);
    }
    const gAng=Math.atan2(WORLD.goal.y-a.y, WORLD.goal.x-a.x);
    const dAng=wrapPI(gAng-a.ang)/Math.PI;
    const dGoal=dist(a.x,a.y, WORLD.goal.x,WORLD.goal.y);
    inputs.push(dAng);
    inputs.push(Math.min(1, dGoal/Math.hypot(WORLD.w,WORLD.h)));
    inputs.push(a.v / a.maxSpeed);
    return new Float32Array(inputs);
  }
  function castRay(x,y,ang,maxR){
    const step=4; let d=0;
    while(d<maxR){
      const px=x+Math.cos(ang)*d, py=y+Math.sin(ang)*d;
      if(px<0||py<0||px>WORLD.w||py>WORLD.h) return d;
      for(const o of WORLD.obstacles){ if(px>=o.x&&px<=o.x+o.w&&py>=o.y&&py<=o.y+o.h) return d; }
      d+=step;
    }
    return maxR;
  }

  // step + reward shaping with "performance emphasis"
  function stepAgent(a){
    if(!a.alive||a.reached) return;
    // ε-greedy noise on outputs to encourage exploration
    const inputs=sense(a);
    let out=forward(a.brain,inputs);
    if(Math.random() < +ui.eps.value){
      out[0] += rand(-0.5,0.5);
      out[1] = Math.random();
    }
    const steer = clamp(out[0],-1,1)*a.steerLimit;
    const throttle = out[1];

    const newAng=a.ang+steer;
    const dYaw=wrapPI(newAng-a.lastAng);
    a.cumTurn += Math.abs(dYaw);
    a.ang=newAng; a.lastAng=newAng;
    if(a.cumTurn >= TWO_TURNS){ a.spun=true; a.alive=false; }

    a.v = clamp(a.v + (throttle-0.25)*a.acc, 0, a.maxSpeed);
    a.x += Math.cos(a.ang)*a.v;
    a.y += Math.sin(a.ang)*a.v;
    a.history.push(a.x,a.y); if(a.history.length>2*140) a.history.splice(0,2);

    // world boundaries
    if(a.x<10||a.y<10||a.x>WORLD.w-10||a.y>WORLD.h-10) a.alive=false;
    if(a.alive){
      for(const o of WORLD.obstacles){
        if(a.x+a.radius>o.x && a.x-a.radius<o.x+o.w && a.y+a.radius>o.y && a.y-a.radius<o.y+o.h){ a.alive=false; break; }
      }
    }

    // goal check
    if(a.alive && dist(a.x,a.y, WORLD.goal.x,WORLD.goal.y)<(WORLD.goal.r+a.radius)){
      a.reached=true; a.alive=false; wins++; roundWon=true;
    }

    // stale tracking
    const dNow=dist(a.x,a.y, WORLD.goal.x,WORLD.goal.y);
    if(dNow < a.minDist - 0.5){ a.minDist=dNow; a.stale=0; } else { a.stale++; if(a.stale > +ui.astal.value) a.alive=false; }

    // reward shaping (computed as fitness proxy)
    const PERF = +ui.perf.value/100; // 0..1 shift toward speed/velocity
    const goalReward = +ui.rGoal.value;
    const progW = +ui.rProg.value * (1 + 0.8*PERF);
    const velW  = +ui.rVel.value  * (0.5 + 1.5*PERF); // emphasize speed under perf
    const spinP = +ui.pSpin.value;
    const crashP= +ui.pCrash.value;

    let fitBase = 1/(1+a.minDist);
    let fitProg = progW * (a.lastDist - dNow); // positive when making progress
    let fitVel  = velW * (a.v / Math.max(0.001,a.maxSpeed));
    let fitSpin = -spinP * (a.cumTurn/(Math.PI*2));
    let fitCrash= (!a.alive && !a.reached) ? -crashP : 0;
    let fitGoal = a.reached ? goalReward : 0;

    a.fitness = Math.max(0, fitBase + fitProg + fitVel + fitSpin + fitCrash + fitGoal);
    a.lastDist = dNow;
    a.steps++;
  }

  function scoreAgent(a){ return a.reached ? +ui.rGoal.value : a.fitness; }

  // ===== Population / GA =====
  let POP=[], POP_SIZE=+ui.pop.value, SENSORS=+ui.sensors.value, MUT=+ui.mut.value, NOISE=+ui.noise.value;
  let bootstrapArchive=[];
  function newPopulationRandom(size=POP_SIZE){
    POP=[]; for(let i=0;i<size;i++){ const brain=createBrain(SENSORS+3); POP.push(makeAgent({brain,sensors:SENSORS,maxSpeed:+ui.vmax.value,steer:+ui.steer.value,acc:+ui.acc.value})); }
  }
  function resetPopulationPositions(){ for(const a of POP) resetAgent(a); }

  function evolve(wasWin=false){
    const eliteK = Math.min(+ui.elite.value, POP.length);
    const blend01 = +ui.blend.value/100;
    const scored=POP.map(a=>({a,fit:scoreAgent(a)})).sort((x,y)=>y.fit-x.fit);
    const bestFit=scored[0].fit;

    // maintain a tiny archive of top performers
    if(bootstrapArchive.length<2) bootstrapArchive.push({brain:cloneBrain(scored[0].a.brain), fit:bestFit});
    else{
      const idxWeak = (bootstrapArchive[0].fit<bootstrapArchive[1].fit)?0:1;
      if(bestFit>bootstrapArchive[idxWeak].fit) bootstrapArchive[idxWeak]={brain:cloneBrain(scored[0].a.brain), fit:bestFit};
    }

    const next=[];
    // carry elites
    for(let i=0;i<eliteK;i++){
      const e = cloneBrain(scored[i].a.brain);
      const agent = makeAgent({brain:e, sensors:SENSORS, maxSpeed:+ui.vmax.value, steer:+ui.steer.value, acc:+ui.acc.value});
      next.push(agent);
    }
    // produce children
    const parentPool = [cloneBrain(scored[0].a.brain), ...(bootstrapArchive.map(x=>x.brain))];
    while(next.length<POP_SIZE){
      const p=parentPool[randi(0,parentPool.length)], q=parentPool[randi(0,parentPool.length)];
      let child=mixBrains(p,q, blend01);
      addNoise(child, NOISE);
      mutate(child, MUT);
      next.push(makeAgent({brain:child, sensors:SENSORS, maxSpeed:+ui.vmax.value, steer:+ui.steer.value, acc:+ui.acc.value}));
    }
    POP=next;

    generation++; ui.gen.textContent=generation; ui.best.textContent=bestFit.toFixed(2); ui.wins.textContent=wins;

    // Optionally rotate map on win
    if(wasWin && ui.autoWin.checked){ regenObstacles(WORLD.nObstacles); bootstrapArchive=[]; }

    resetPopulationPositions();
    genBestMinDist=Infinity; genStaleTicks=0; simTicks=0;
  }

  // ===== Main loop =====
  let acc=0,lastT=0,simTicks=0, roundWon=false;
  let genBestMinDist=Infinity, genStaleTicks=0;
  function update(){
    simTicks++;
    let allDone=true, improved=false;
    for(const a of POP){
      if(a.alive){ stepAgent(a); allDone=false; }
      if(a.minDist < genBestMinDist - 0.5){ genBestMinDist=a.minDist; improved=true; }
    }
    genStaleTicks = improved ? 0 : genStaleTicks+1;

    if(roundWon || allDone || simTicks>= +ui.round.value || genStaleTicks >= +ui.gstal.value){
      evolve(roundWon); roundWon=false;
    }
  }
  function loop(t){
    const dt=Math.min(32, t-lastT); lastT=t;
    acc += dt * tickScale;
    const stepMs=16;
    while(acc>=stepMs){ update(); acc-=stepMs; }
    render();
    if(running) requestAnimationFrame(loop);
  }

  // ===== Render =====
  function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }
  function render(){
    const W=canvas.width,H=canvas.height;
    ctx.clearRect(0,0,W,H);
    const scale=Math.min(W/WORLD.w, H/WORLD.h);
    const ox=(W-WORLD.w*scale)/2, oy=(H-WORLD.h*scale)/2;
    const tx=x=>Math.round(ox+x*scale), ty=y=>Math.round(oy+y*scale), ts=s=>Math.max(1,Math.round(s*scale));

    ctx.fillStyle='#0c1730'; roundRect(ctx,ox-8,oy-8,WORLD.w*scale+16,WORLD.h*scale+16,14); ctx.fill();

    // goal
    ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(tx(WORLD.goal.x), ty(WORLD.goal.y), ts(WORLD.goal.r), 0, Math.PI*2); ctx.fill();

    // obstacles
    ctx.fillStyle='#ff7b72';
    for(const o of WORLD.obstacles){ roundRect(ctx, tx(o.x),ty(o.y), ts(o.w),ts(o.h), 8); ctx.fill(); }

    // best selection by fitness
    let best=POP[0]; for(const a of POP){ if(a.fitness>best.fitness) best=a; }

    for(const a of POP){
      const isBest=(a===best);

      if(a.history.length>4){
        ctx.globalAlpha=isBest?0.9:0.4;
        ctx.strokeStyle=isBest?'#7ee787':'#58a6ff';
        ctx.lineWidth=isBest?3:1.5;
        ctx.beginPath();
        for(let i=0;i<a.history.length;i+=2){ const px=tx(a.history[i]), py=ty(a.history[i+1]); if(i===0) ctx.moveTo(px,py); else ctx.lineTo(px,py); }
        ctx.stroke(); ctx.globalAlpha=1;
      }

      ctx.fillStyle=isBest?'#7ee787':(a.spun?'#aa5577':'#58a6ff');
      ctx.beginPath(); ctx.arc(tx(a.x), ty(a.y), ts(a.radius), 0, Math.PI*2); ctx.fill();

      // direction tick
      ctx.strokeStyle='#000'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.moveTo(tx(a.x),ty(a.y));
      ctx.lineTo(tx(a.x+Math.cos(a.ang)*a.radius*1.4), ty(a.y+Math.sin(a.ang)*a.radius*1.4));
      ctx.stroke();

      // sensors for best
      if(isBest){
        const n=a.sensors, maxR=+ui.srange.value, spread=(+ui.fov.value)*Math.PI/180;
        ctx.strokeStyle='rgba(255,255,255,0.25)'; ctx.lineWidth=1;
        for(let i=0;i<n;i++){
          const ang=a.ang + (i/(n-1)-0.5)*spread;
          const d=castRay(a.x,a.y,ang,maxR);
          ctx.beginPath(); ctx.moveTo(tx(a.x),ty(a.y)); ctx.lineTo(tx(a.x+Math.cos(ang)*d), ty(a.y+Math.sin(ang)*d)); ctx.stroke();
        }
      }
    }

    ctx.fillStyle='rgba(255,255,255,0.7)';
    ctx.font=`${Math.round(14*DPR)}px system-ui,-apple-system,Segoe UI,Roboto,Arial`;
    ctx.fillText(`Gen ${generation}   Wins ${wins}`, 14*DPR, 22*DPR);
  }

  // ===== Controls / Wiring =====
  function nextMap(){
    generation=0; ui.gen.textContent='0'; ui.best.textContent='0.00'; bootstrapArchive=[];
    regenObstacles(WORLD.nObstacles);
    newPopulationRandom(POP_SIZE);
    resetPopulationPositions();
    simTicks=0; genBestMinDist=Infinity; genStaleTicks=0; roundWon=false;
    render();
  }

  // reactive bindings
  ui.speed.addEventListener('input', ()=> tickScale=+ui.speed.value);
  ui.pop.addEventListener('change', ()=>{ POP_SIZE=+ui.pop.value; rebuild(false); });
  ui.mut.addEventListener('input', ()=> MUT=+ui.mut.value);
  ui.noise.addEventListener('input', ()=> NOISE=+ui.noise.value);
  ui.sensors.addEventListener('change', ()=>{ SENSORS=+ui.sensors.value; rebuild(true); });
  for(const id of ['vmax','steer','acc']) ui[id].addEventListener('input', ()=>{
    for(const a of POP){ a.maxSpeed=+ui.vmax.value; a.steerLimit=+ui.steer.value; a.acc=+ui.acc.value; }
  });
  for(const id of ['goalr','pad','ldist','lhalf']){
    ui[id].addEventListener('input', ()=>{
      WORLD.goal.r = +ui.goalr.value;
      SAFETY.goalRadius = +ui.goalr.value;
      SAFETY.wallPad = +ui.pad.value;
      SAFETY.launchDist = +ui.ldist.value;
      SAFETY.launchHalfAngle = (+ui.lhalf.value)*Math.PI/180;
      render();
    });
  }
  ui.obs.addEventListener('change', ()=>{ WORLD.nObstacles=+ui.obs.value; nextMap(); });
  // rewards and perf change instantly; no rebuild needed
  for(const id of ['perf','rGoal','rProg','rVel','pSpin','pCrash','fov','srange','eps','round','gstal','astal']) ui[id].addEventListener('input', ()=>{});

  btnToggle.addEventListener('click', ()=>{
    running=!running; btnToggle.textContent = running ? '⏸ Pause' : '▶ Run';
    if(running){ lastT=performance.now(); requestAnimationFrame(loop); }
  });
  btnStep.addEventListener('click', ()=>{ if(running) return; for(let i=0;i<8;i++) update(); render(); });
  btnReset.addEventListener('click', nextMap);

  function rebuild(newBrains){
    const next=[];
    if(newBrains){
      for(let i=0;i<POP_SIZE;i++){ const brain=createBrain(SENSORS+3); next.push(makeAgent({brain,sensors:SENSORS,maxSpeed:+ui.vmax.value,steer:+ui.steer.value,acc:+ui.acc.value})); }
    }else{
      for(let i=0;i<Math.min(POP.length,POP_SIZE);i++){
        const b=cloneBrain(POP[i].brain); addNoise(b, Math.max(NOISE,3)); // light noise
        next.push(makeAgent({brain:b,sensors:SENSORS,maxSpeed:+ui.vmax.value,steer:+ui.steer.value,acc:+ui.acc.value}));
      }
      while(next.length<POP_SIZE){
        const brain=createBrain(SENSORS+3);
        next.push(makeAgent({brain,sensors:SENSORS,maxSpeed:+ui.vmax.value,steer:+ui.steer.value,acc:+ui.acc.value}));
      }
    }
    POP=next; resetPopulationPositions();
  }

  function hardBoot(){
    WORLD.w=Math.round(Math.max(680, window.innerWidth*0.9));
    WORLD.h=Math.round(Math.max(420, (window.innerHeight-140)*0.9));
    WORLD.start={x:0.1*WORLD.w, y:0.5*WORLD.h};
    WORLD.goal ={x:0.9*WORLD.w, y:0.5*WORLD.h, r:+ui.goalr.value};
    regenObstacles(WORLD.nObstacles);
    newPopulationRandom(POP_SIZE);
    resetPopulationPositions();
    render();
  }

  // Boot
  tickScale=+ui.speed.value; hardBoot();
  setTimeout(()=>{ if(!running) btnToggle.click(); },300);
})();
</script>
</body>
</html>
